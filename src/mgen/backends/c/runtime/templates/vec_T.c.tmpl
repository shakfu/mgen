/**
 * Simple dynamic array for {{T_SUFFIX}} - Implementation
 * STC-compatible naming for drop-in replacement
 */

#include "mgen_vec_{{T_SUFFIX}}.h"
#include "mgen_error_handling.h"
#include <stdlib.h>
#include <string.h>

#define DEFAULT_CAPACITY 8
#define GROWTH_FACTOR 2

vec_{{T_SUFFIX}} vec_{{T_SUFFIX}}_init(void) {
    vec_{{T_SUFFIX}} vec;
    vec.capacity = DEFAULT_CAPACITY;
    vec.size = 0;
    vec.data = malloc(DEFAULT_CAPACITY * sizeof({{T}}));
    if (!vec.data) {
        MGEN_SET_ERROR(MGEN_ERROR_MEMORY, "Failed to allocate vector");
        vec.capacity = 0;
    }
    return vec;
}

static void vec_{{T_SUFFIX}}_grow(vec_{{T_SUFFIX}}* vec) {
    // Handle first allocation if capacity is 0
    size_t new_capacity = (vec->capacity == 0) ? DEFAULT_CAPACITY : vec->capacity * GROWTH_FACTOR;
    {{T}}* new_data = realloc(vec->data, new_capacity * sizeof({{T}}));
    if (!new_data) {
        MGEN_SET_ERROR(MGEN_ERROR_MEMORY, "Failed to grow vector");
        return;
    }
    vec->data = new_data;
    vec->capacity = new_capacity;
}

void vec_{{T_SUFFIX}}_push(vec_{{T_SUFFIX}}* vec, {{#T_IS_POINTER}}const {{/T_IS_POINTER}}{{T}} value) {
    if (!vec) {
        MGEN_SET_ERROR(MGEN_ERROR_VALUE, "NULL vector");
        return;
    }

    if (vec->size >= vec->capacity) {
        vec_{{T_SUFFIX}}_grow(vec);
    }

{{#T_NEEDS_COPY}}
    // Duplicate the string to take ownership
    // Handle NULL strings by storing NULL
    if (value) {
        vec->data[vec->size] = strdup(value);
        if (!vec->data[vec->size]) {
            MGEN_SET_ERROR(MGEN_ERROR_MEMORY, "Failed to duplicate string");
            return;
        }
    } else {
        vec->data[vec->size] = NULL;
    }
    vec->size++;
    return;
{{/T_NEEDS_COPY}}

    vec->data[vec->size++] = value;
}

{{T}}* vec_{{T_SUFFIX}}_at(vec_{{T_SUFFIX}}* vec, size_t index) {
    if (!vec) {
        MGEN_SET_ERROR(MGEN_ERROR_VALUE, "NULL vector");
        return NULL;
    }

    if (index >= vec->size) {
        MGEN_SET_ERROR(MGEN_ERROR_INDEX, "Index out of bounds");
        return NULL;
    }

    return &vec->data[index];
}

size_t vec_{{T_SUFFIX}}_size(const vec_{{T_SUFFIX}}* vec) {
    return vec ? vec->size : 0;
}

size_t vec_{{T_SUFFIX}}_capacity(const vec_{{T_SUFFIX}}* vec) {
    return vec ? vec->capacity : 0;
}

void vec_{{T_SUFFIX}}_pop(vec_{{T_SUFFIX}}* vec) {
    if (!vec || vec->size == 0) {
        MGEN_SET_ERROR(MGEN_ERROR_VALUE, "Empty or NULL vector");
        return;
    }

{{#T_NEEDS_DROP}}
    // Free the last element before removing it
    vec->size--;
    free(vec->data[vec->size]);
    vec->data[vec->size] = NULL;
    return;
{{/T_NEEDS_DROP}}

    vec->size--;
}

void vec_{{T_SUFFIX}}_clear(vec_{{T_SUFFIX}}* vec) {
    if (!vec) {
        return;
    }

{{#T_NEEDS_DROP}}
    // Free all elements
    for (size_t i = 0; i < vec->size; i++) {
        free(vec->data[i]);
        vec->data[i] = NULL;
    }
{{/T_NEEDS_DROP}}

    vec->size = 0;
}

void vec_{{T_SUFFIX}}_drop(vec_{{T_SUFFIX}}* vec) {
    if (!vec) {
        return;
    }

{{#T_NEEDS_DROP}}
    // Free all elements
    for (size_t i = 0; i < vec->size; i++) {
        free(vec->data[i]);
    }
{{/T_NEEDS_DROP}}

    free(vec->data);
    vec->data = NULL;
    vec->size = 0;
    vec->capacity = 0;
}

bool vec_{{T_SUFFIX}}_empty(const vec_{{T_SUFFIX}}* vec) {
    return !vec || vec->size == 0;
}

void vec_{{T_SUFFIX}}_reserve(vec_{{T_SUFFIX}}* vec, size_t new_capacity) {
    if (!vec) {
        MGEN_SET_ERROR(MGEN_ERROR_VALUE, "NULL vector");
        return;
    }

    if (new_capacity <= vec->capacity) {
        return; // Already have enough capacity
    }

    {{T}}* new_data = realloc(vec->data, new_capacity * sizeof({{T}}));
    if (!new_data) {
        MGEN_SET_ERROR(MGEN_ERROR_MEMORY, "Failed to reserve capacity");
        return;
    }

    vec->data = new_data;
    vec->capacity = new_capacity;
}
