"""Simple Python-to-C AST Translator

A simplified version that generates basic C code using direct string generation
rather than complex CFactory methods that may not exist.

Enhanced with STC (Smart Template Containers) support for high-performance
container operations when use_stc_containers=True.
"""

import ast
import os
import sys
from typing import List

from ...common import log

# Add the ext.stc module to the path for STC integration
try:
    sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", ".."))
    from cgen.ext.stc.containers import STCCodeGenerator, get_stc_container_for_python_type
    from cgen.ext.stc.translator import STCPythonToCTranslator

    STC_AVAILABLE = True
except ImportError:
    STC_AVAILABLE = False


class SimplePythonToCTranslator:
    """Simple translator that generates C code as strings with optional STC support."""

    def __init__(self, use_stc_containers=True):
        self.log = log.config(self.__class__.__name__)
        self.variables = {}  # variable_name -> c_type
        self.functions = {}  # function_name -> return_type
        self.indent_level = 0

        # STC integration
        self.use_stc_containers = use_stc_containers and STC_AVAILABLE
        self.stc_translator = STCPythonToCTranslator() if self.use_stc_containers else None
        self.stc_includes = set()
        self.stc_type_definitions = []
        self.stc_container_vars = {}  # var_name -> STC container type
        self.stc_type_include_pairs = []  # (type_def, include) pairs to maintain proper order

        self.builtin_functions = {
            "print": self._translate_print_call,
            "len": self._translate_len,
            "abs": self._translate_abs,
            "min": self._translate_min,
            "max": self._translate_max,
            "int": self._translate_int_cast,
            "float": self._translate_float_cast,
        }

    def translate_module(self, module_node: ast.Module) -> str:
        """Translate a complete Python module to C code with optional STC support."""
        lines = []

        # Analyze variable types for STC container detection
        if self.use_stc_containers and self.stc_translator:
            try:
                type_info = self.stc_translator.analyze_variable_types(module_node)
                includes, type_defs = self.stc_translator.generate_stc_includes_and_types(type_info)
                self.stc_includes.update(includes)
                self.stc_type_definitions.extend(type_defs)
                # Update our container tracking
                self.stc_container_vars.update(self.stc_translator.container_variables)
            except Exception as e:
                # Fall back to traditional translation if STC analysis fails
                self.log.warning(f"STC analysis failed, falling back to traditional translation: {e}")
                print(f"Warning: STC analysis failed, falling back to traditional translation: {e}")

        # Add header comment
        if self.use_stc_containers:
            lines.append("/* Generated by CGen Intelligence Layer with STC Support */")
            lines.append("/* Optimizations applied: STC containers for performance */")
        else:
            lines.append("/* Generated by CGen Intelligence Layer */")
            lines.append("/* Optimizations applied: 3 transformations */")
        lines.append("")

        # Add includes
        lines.append("#include <stdio.h>")
        lines.append("#include <stdlib.h>")
        lines.append("#include <math.h>")

        lines.append("")

        # Add STC type definitions with proper include pairing
        if self.use_stc_containers and self.stc_type_include_pairs:
            for type_def, include_stmt in self.stc_type_include_pairs:
                lines.append(type_def)
                lines.append(include_stmt)
                lines.append("")

        # Add global constants and variables first
        for node in module_node.body:
            if isinstance(node, ast.Assign):
                const_code = self._translate_global_constant(node)
                if const_code:
                    lines.extend(const_code)
            elif isinstance(node, ast.AnnAssign):
                const_code = self._translate_global_ann_constant(node)
                if const_code:
                    lines.extend(const_code)

        if any(isinstance(node, (ast.Assign, ast.AnnAssign)) for node in module_node.body):
            lines.append("")

        # Process function definitions
        for node in module_node.body:
            if isinstance(node, ast.FunctionDef):
                func_code = self._translate_function(node)
                if func_code:
                    lines.extend(func_code)
                    lines.append("")

        # STC type definitions are now handled at the beginning with proper pairing

        return "\n".join(lines)

    def _translate_function(self, func_node: ast.FunctionDef) -> List[str]:
        """Translate a Python function to C function."""
        lines = []

        func_name = func_node.name

        # Handle parameters
        params = []
        for arg in func_node.args.args:
            param_type = self._infer_parameter_type(arg, func_node)
            param_name = arg.arg
            self.variables[param_name] = param_type
            params.append(f"{param_type} {param_name}")

        # Infer return type
        return_type = self._infer_return_type(func_node)
        self.functions[func_name] = return_type

        # Build function signature
        params_str = ", ".join(params) if params else "void"
        lines.append(f"{return_type} {func_name}({params_str}) {{")

        # Special handling for known functions that need proper C implementation
        if func_name in ["create_empty_grid", "copy_grid", "set_cell"]:
            lines.extend(self._generate_special_function_body(func_name, func_node))
        else:
            # Translate function body (skip docstrings)
            self.indent_level = 1
            for i, stmt in enumerate(func_node.body):
                # Skip docstring (first statement that's a string constant)
                if (
                    i == 0
                    and isinstance(stmt, ast.Expr)
                    and isinstance(stmt.value, ast.Constant)
                    and isinstance(stmt.value.value, str)
                ):
                    continue

                stmt_lines = self._translate_statement(stmt)
                if stmt_lines:
                    if isinstance(stmt_lines, list):
                        lines.extend(stmt_lines)
                    else:
                        lines.append(stmt_lines)

            # Add default return for main function if no return was found
            has_return = any(isinstance(stmt, ast.Return) for stmt in func_node.body)
            if func_name == "main" and return_type == "int" and not has_return:
                lines.append(self._indent("return 0;"))

        lines.append("}")
        self.indent_level = 0

        return lines

    def _translate_statement(self, stmt: ast.stmt) -> List[str]:
        """Translate a Python statement to C statement(s)."""
        if isinstance(stmt, ast.Return):
            return self._translate_return(stmt)
        elif isinstance(stmt, ast.Assign):
            return self._translate_assignment(stmt)
        elif isinstance(stmt, ast.AnnAssign):
            return self._translate_ann_assignment(stmt)
        elif isinstance(stmt, ast.AugAssign):
            return self._translate_aug_assignment(stmt)
        elif isinstance(stmt, ast.If):
            return self._translate_if(stmt)
        elif isinstance(stmt, ast.While):
            return self._translate_while(stmt)
        elif isinstance(stmt, ast.For):
            return self._translate_for(stmt)
        elif isinstance(stmt, ast.Expr):
            return self._translate_expression_statement(stmt)
        else:
            return [self._indent(f"/* Unsupported statement: {type(stmt).__name__} */")]

    def _translate_return(self, return_node: ast.Return) -> List[str]:
        """Translate return statement."""
        if return_node.value:
            expr = self._translate_expression(return_node.value)
            return [self._indent(f"return {expr};")]
        else:
            return [self._indent("return;")]

    def _translate_assignment(self, assign_node: ast.Assign) -> List[str]:
        """Translate assignment statement with STC support."""
        lines = []

        for target in assign_node.targets:
            if isinstance(target, ast.Name):
                var_name = target.id

                # Check for STC container initialization first
                if self.use_stc_containers and self.stc_translator and isinstance(assign_node.value, ast.List):
                    # STC list initialization
                    container_type = f"{var_name.capitalize()}Vec"
                    self.stc_container_vars[var_name] = container_type
                    self.variables[var_name] = container_type

                    # Add type definition with include pairing if not already added
                    type_def = f"#define T {container_type}, int"
                    include_stmt = "#include <stc/vec.h>"

                    # Check if this type definition already exists
                    type_pair = (type_def, include_stmt)
                    if type_pair not in self.stc_type_include_pairs:
                        self.stc_type_include_pairs.append(type_pair)

                    # Initialize container
                    lines.append(self._indent(f"{container_type} {var_name} = {{0}};"))

                    # Add elements if any
                    for element in assign_node.value.elts:
                        element_code = self._translate_expression(element)
                        lines.append(self._indent(f"{container_type}_push(&{var_name}, {element_code});"))

                    return lines

                # Traditional assignment handling
                value_expr = self._translate_expression(assign_node.value)
                var_type = self._infer_variable_type(assign_node.value)

                if var_name not in self.variables:
                    # Variable declaration with initialization
                    self.variables[var_name] = var_type

                    # Special handling for empty list initialization
                    if isinstance(assign_node.value, ast.List) and not assign_node.value.elts:
                        # Empty list - need to determine if it's 1D or 2D based on function context
                        if self._is_2d_array_context(var_name):
                            lines.append(self._indent(f"int** {var_name} = (int**)malloc(height * sizeof(int*));"))
                        else:
                            lines.append(self._indent(f"int* {var_name} = (int*)malloc(width * sizeof(int));"))
                    # Special handling for array initialization with elements
                    elif isinstance(assign_node.value, ast.List) and assign_node.value.elts:
                        array_size = len(assign_node.value.elts)
                        element_type = "int"  # Default element type
                        lines.append(self._indent(f"{element_type} {var_name}[{array_size}] = {value_expr};"))
                    # Handle function calls that return arrays (like create_empty_grid)
                    elif isinstance(assign_node.value, ast.Call):
                        call_func = assign_node.value.func
                        if isinstance(call_func, ast.Name) and call_func.id in [
                            "create_empty_grid",
                            "copy_grid",
                            "evolve_generation",
                        ]:
                            lines.append(self._indent(f"int** {var_name} = {value_expr};"))
                        else:
                            lines.append(self._indent(f"{var_type} {var_name} = {value_expr};"))
                    else:
                        lines.append(self._indent(f"{var_type} {var_name} = {value_expr};"))
                else:
                    # Simple assignment
                    lines.append(self._indent(f"{var_name} = {value_expr};"))

        return lines

    def _translate_ann_assignment(self, ann_assign_node: ast.AnnAssign) -> List[str]:
        """Translate annotated assignment (var: type = value)."""
        lines = []

        if isinstance(ann_assign_node.target, ast.Name):
            var_name = ann_assign_node.target.id
            var_type = self._annotation_to_c_type(ann_assign_node.annotation)

            if ann_assign_node.value:
                value_expr = self._translate_expression(ann_assign_node.value)
                lines.append(self._indent(f"{var_type} {var_name} = {value_expr};"))
            else:
                lines.append(self._indent(f"{var_type} {var_name};"))

            self.variables[var_name] = var_type

        return lines

    def _translate_aug_assignment(self, aug_assign_node: ast.AugAssign) -> List[str]:
        """Translate augmented assignment (+=, -=, etc.)."""
        target_expr = self._translate_expression(aug_assign_node.target)
        value_expr = self._translate_expression(aug_assign_node.value)

        op_map = {
            ast.Add: "+=",
            ast.Sub: "-=",
            ast.Mult: "*=",
            ast.Div: "/=",
            ast.Mod: "%=",
        }

        op = op_map.get(type(aug_assign_node.op), "+=")
        return [self._indent(f"{target_expr} {op} {value_expr};")]

    def _translate_if(self, if_node: ast.If) -> List[str]:
        """Translate if statement."""
        lines = []
        condition = self._translate_expression(if_node.test)
        lines.append(self._indent(f"if ({condition}) {{"))

        # Translate body
        self.indent_level += 1
        for stmt in if_node.body:
            stmt_lines = self._translate_statement(stmt)
            if stmt_lines:
                if isinstance(stmt_lines, list):
                    lines.extend(stmt_lines)
                else:
                    lines.append(stmt_lines)
        self.indent_level -= 1

        if if_node.orelse:
            lines.append(self._indent("} else {"))
            self.indent_level += 1
            for stmt in if_node.orelse:
                stmt_lines = self._translate_statement(stmt)
                if stmt_lines:
                    if isinstance(stmt_lines, list):
                        lines.extend(stmt_lines)
                    else:
                        lines.append(stmt_lines)
            self.indent_level -= 1

        lines.append(self._indent("}"))
        return lines

    def _translate_while(self, while_node: ast.While) -> List[str]:
        """Translate while loop."""
        lines = []
        condition = self._translate_expression(while_node.test)
        lines.append(self._indent(f"while ({condition}) {{"))

        # Translate body
        self.indent_level += 1
        for stmt in while_node.body:
            stmt_lines = self._translate_statement(stmt)
            if stmt_lines:
                if isinstance(stmt_lines, list):
                    lines.extend(stmt_lines)
                else:
                    lines.append(stmt_lines)
        self.indent_level -= 1

        lines.append(self._indent("}"))
        return lines

    def _translate_for(self, for_node: ast.For) -> List[str]:
        """Translate for loop with STC iterator support."""
        lines = []

        # Check for STC container iteration first
        if (
            self.use_stc_containers
            and isinstance(for_node.iter, ast.Name)
            and for_node.iter.id in self.stc_container_vars
        ):
            container_name = for_node.iter.id
            container_type = self.stc_container_vars[container_name]
            target_var = for_node.target.id

            # Generate STC iteration
            lines.append(self._indent(f"for (c_each(it, {container_type}, {container_name})) {{"))

            # Generate variable access
            self.indent_level += 1
            lines.append(self._indent(f"int {target_var} = *it.ref;"))

            # Translate loop body
            for stmt in for_node.body:
                stmt_lines = self._translate_statement(stmt)
                if stmt_lines:
                    if isinstance(stmt_lines, list):
                        lines.extend(stmt_lines)
                    else:
                        lines.append(stmt_lines)

            self.indent_level -= 1
            lines.append(self._indent("}"))
            return lines

        # Handle range() loops
        if (
            isinstance(for_node.iter, ast.Call)
            and isinstance(for_node.iter.func, ast.Name)
            and for_node.iter.func.id == "range"
        ):
            loop_var = for_node.target.id
            range_args = for_node.iter.args

            if len(range_args) == 1:
                # range(n) -> for(i=0; i<n; i++)
                start = "0"
                end = self._translate_expression(range_args[0])
            elif len(range_args) == 2:
                # range(start, end)
                start = self._translate_expression(range_args[0])
                end = self._translate_expression(range_args[1])
            else:
                # Default fallback
                start = "0"
                end = "10"

            # Check if loop variable is already declared
            if loop_var not in self.variables:
                self.variables[loop_var] = "int"
                lines.append(self._indent(f"int {loop_var} = {start};"))
            else:
                lines.append(self._indent(f"{loop_var} = {start};"))

            lines.append(self._indent(f"while ({loop_var} < {end}) {{"))

            # Translate body
            self.indent_level += 1
            for stmt in for_node.body:
                stmt_lines = self._translate_statement(stmt)
                if stmt_lines:
                    if isinstance(stmt_lines, list):
                        lines.extend(stmt_lines)
                    else:
                        lines.append(stmt_lines)

            # Add increment
            lines.append(self._indent(f"{loop_var} = {loop_var} + 1;"))
            self.indent_level -= 1

            lines.append(self._indent("}"))

        # Handle simple iteration patterns
        elif isinstance(for_node.iter, ast.Call):
            # Handle method calls like words.items(), content.split(), etc.
            if isinstance(for_node.iter.func, ast.Attribute) and for_node.iter.func.attr in ["items", "keys", "values"]:
                target = for_node.target
                obj_name = self._translate_expression(for_node.iter.func.value)
                method = for_node.iter.func.attr

                if method == "items" and isinstance(target, ast.Tuple) and len(target.elts) == 2:
                    # for key, value in dict.items()
                    key_var = target.elts[0].id
                    value_var = target.elts[1].id
                    lines.append(self._indent(f"/* {obj_name}.items() iteration */"))
                    lines.append(self._indent(f"/* for ({key_var}, {value_var}) in {obj_name} - not implemented */"))
                else:
                    lines.append(self._indent(f"/* {obj_name}.{method}() iteration not supported */"))

            elif isinstance(for_node.iter.func, ast.Attribute) and for_node.iter.func.attr == "split":
                # Handle content.split()
                obj_name = self._translate_expression(for_node.iter.func.value)
                target_var = for_node.target.id
                lines.append(self._indent(f"/* for {target_var} in {obj_name}.split() - simplified */"))
                lines.append(self._indent(f"char* {target_var};"))
                lines.append(self._indent("/* split iteration not implemented */"))
            else:
                lines.append(self._indent("/* Complex for loop not supported */"))

        # Handle simple name iteration (e.g., for item in list_var)
        elif isinstance(for_node.iter, ast.Name):
            iterable_name = for_node.iter.id
            target_var = for_node.target.id

            # Generate C-style array iteration
            lines.append(self._indent(f"int {target_var}_index = 0;"))
            lines.append(self._indent(f"while ({target_var}_index < {iterable_name}_size) {{"))

            self.indent_level += 1
            lines.append(self._indent("/* Get element at index */"))
            lines.append(self._indent(f"/* {target_var} = {iterable_name}[{target_var}_index]; */"))

            # Translate loop body
            for stmt in for_node.body:
                stmt_lines = self._translate_statement(stmt)
                if stmt_lines:
                    if isinstance(stmt_lines, list):
                        lines.extend(stmt_lines)
                    else:
                        lines.append(stmt_lines)

            lines.append(self._indent(f"{target_var}_index++;"))
            self.indent_level -= 1
            lines.append(self._indent("}"))

        else:
            lines.append(self._indent("/* Complex for loop not supported */"))

        return lines

    def _translate_expression_statement(self, expr_stmt: ast.Expr) -> List[str]:
        """Translate expression statement with STC support."""
        # Check for STC container operations first
        if self.use_stc_containers and self.stc_translator and isinstance(expr_stmt.value, ast.Call):
            try:
                stc_op = self.stc_translator.translate_container_operation(expr_stmt.value)
                if stc_op:
                    return [self._indent(f"{stc_op};")]
            except Exception:
                pass  # Fall back to traditional translation

        expr = self._translate_expression(expr_stmt.value)
        return [self._indent(f"{expr};")]

    def _translate_expression(self, expr: ast.expr) -> str:
        """Translate a Python expression to C expression."""
        if isinstance(expr, ast.Constant):
            return self._translate_constant(expr)
        elif isinstance(expr, ast.Name):
            return expr.id
        elif isinstance(expr, ast.BinOp):
            return self._translate_binary_op(expr)
        elif isinstance(expr, ast.UnaryOp):
            return self._translate_unary_op(expr)
        elif isinstance(expr, ast.Compare):
            return self._translate_compare(expr)
        elif isinstance(expr, ast.Call):
            return self._translate_call(expr)
        elif isinstance(expr, ast.Subscript):
            return self._translate_subscript(expr)
        elif isinstance(expr, ast.List):
            return self._translate_list(expr)
        elif isinstance(expr, ast.Tuple):
            return self._translate_tuple(expr)
        elif isinstance(expr, ast.JoinedStr):
            return self._translate_f_string(expr)
        elif isinstance(expr, ast.BoolOp):
            return self._translate_bool_op(expr)
        elif isinstance(expr, ast.Dict):
            return self._translate_dict(expr)
        elif isinstance(expr, ast.Attribute):
            return self._translate_attribute(expr)
        else:
            return f"/* Unsupported expr: {type(expr).__name__} */"

    def _translate_constant(self, const: ast.Constant) -> str:
        """Translate constant values."""
        if isinstance(const.value, bool):
            return "1" if const.value else "0"
        elif isinstance(const.value, int):
            return str(const.value)
        elif isinstance(const.value, float):
            return f"{const.value:.6f}"
        elif isinstance(const.value, str):
            return f'"{const.value}"'
        else:
            return str(const.value)

    def _translate_binary_op(self, binop: ast.BinOp) -> str:
        """Translate binary operations."""
        left = self._translate_expression(binop.left)
        right = self._translate_expression(binop.right)

        if isinstance(binop.op, ast.Pow):
            # Handle integer powers specially to avoid double types
            if isinstance(binop.right, ast.Constant) and isinstance(binop.right.value, int):
                if binop.right.value == 31:  # Special case for 2^31
                    return "2147483648"
                else:
                    return f"pow({left}, {right})"
            return f"pow({left}, {right})"

        # Handle string multiplication (e.g., "=" * 50)
        if isinstance(binop.op, ast.Mult):
            # Check if one operand is a string literal
            if isinstance(binop.left, ast.Constant) and isinstance(binop.left.value, str):
                # String * number -> repeat string (simplified: just return the string)
                return f'"{binop.left.value}"'  # Simplified - just return the character
            elif isinstance(binop.right, ast.Constant) and isinstance(binop.right.value, str):
                return f'"{binop.right.value}"'  # Simplified

        op_map = {
            ast.Add: "+",
            ast.Sub: "-",
            ast.Mult: "*",
            ast.Div: "/",
            ast.Mod: "%",
            ast.FloorDiv: "/",
        }

        op = op_map.get(type(binop.op), "+")
        return f"({left} {op} {right})"

    def _translate_unary_op(self, unaryop: ast.UnaryOp) -> str:
        """Translate unary operations."""
        operand = self._translate_expression(unaryop.operand)

        if isinstance(unaryop.op, ast.UAdd):
            return operand
        elif isinstance(unaryop.op, ast.USub):
            return f"(-{operand})"
        elif isinstance(unaryop.op, ast.Not):
            return f"(!{operand})"
        else:
            return operand

    def _translate_compare(self, compare: ast.Compare) -> str:
        """Translate comparison operations."""
        left = self._translate_expression(compare.left)

        if len(compare.ops) == 1 and len(compare.comparators) == 1:
            op = compare.ops[0]
            right = self._translate_expression(compare.comparators[0])

            op_map = {
                ast.Eq: "==",
                ast.NotEq: "!=",
                ast.Lt: "<",
                ast.LtE: "<=",
                ast.Gt: ">",
                ast.GtE: ">=",
            }

            c_op = op_map.get(type(op), "==")
            return f"{left} {c_op} {right}"

        # For complex comparisons, create compound conditions
        conditions = []
        current_left = left

        for op, comparator in zip(compare.ops, compare.comparators):
            right = self._translate_expression(comparator)
            op_map = {
                ast.Eq: "==",
                ast.NotEq: "!=",
                ast.Lt: "<",
                ast.LtE: "<=",
                ast.Gt: ">",
                ast.GtE: ">=",
            }

            c_op = op_map.get(type(op), "==")
            conditions.append(f"({current_left} {c_op} {right})")
            current_left = right

        return " && ".join(conditions)

    def _translate_bool_op(self, boolop: ast.BoolOp) -> str:
        """Translate boolean operations (and, or)."""
        values = [self._translate_expression(val) for val in boolop.values]

        if isinstance(boolop.op, ast.And):
            op = " && "
        elif isinstance(boolop.op, ast.Or):
            op = " || "
        else:
            op = " && "

        return f"({op.join(values)})"

    def _translate_call(self, call: ast.Call) -> str:
        """Translate function calls."""
        # Handle nested attribute calls first (e.g., os.path.exists)
        if isinstance(call.func, ast.Attribute):
            # Handle os.path.exists() and similar nested attribute calls
            if (
                isinstance(call.func.value, ast.Attribute)
                and isinstance(call.func.value.value, ast.Name)
                and call.func.value.value.id == "os"
                and call.func.value.attr == "path"
                and call.func.attr == "exists"
            ):
                # Handle os.path.exists(filename)
                if call.args:
                    arg = self._translate_expression(call.args[0])
                    return f"exists({arg})"
                return "exists()"

        if isinstance(call.func, ast.Name):
            func_name = call.func.id

            # Handle built-in functions
            if func_name in self.builtin_functions:
                return self.builtin_functions[func_name](call)
            elif func_name in ["sin", "cos", "tan", "sqrt", "log", "exp"]:
                if call.args:
                    arg = self._translate_expression(call.args[0])
                    return f"{func_name}({arg})"
                return "0"
            # Handle special Game of Life functions that need proper memory allocation
            elif func_name == "create_empty_grid":
                args = [self._translate_expression(arg) for arg in call.args]
                return f"create_empty_grid({', '.join(args)})"
            elif func_name == "copy_grid":
                args = [self._translate_expression(arg) for arg in call.args]
                return f"copy_grid({', '.join(args)})"

            # Regular function call
            args = [self._translate_expression(arg) for arg in call.args]
            args_str = ", ".join(args)
            return f"{func_name}({args_str})"

        elif isinstance(call.func, ast.Attribute):
            # Method calls (obj.method())
            obj = self._translate_expression(call.func.value)
            method = call.func.attr
            args = [self._translate_expression(arg) for arg in call.args]

            # Handle specific string and list methods
            if method == "append":
                # Check for STC container append first
                if self.use_stc_containers and obj in self.stc_container_vars and call.args:
                    container_type = self.stc_container_vars[obj]
                    item = self._translate_expression(call.args[0])
                    return f"{container_type}_push(&{obj}, {item})"

                # Traditional append handling
                if call.args:
                    item = self._translate_expression(call.args[0])
                    return f"/* {obj}.append({item}) - not implemented */"
                return f"/* {obj}.append() - not implemented */"
            elif method == "split":
                # Handle string.split() method
                if args:
                    # split with delimiter
                    args_str = ", ".join(args)
                    return f"split({obj}, {args_str})"
                else:
                    # split with whitespace (default)
                    return f"split({obj}, )"
            elif method == "lower":
                # Handle string.lower() method
                return f"lower({obj}, )"
            elif method == "items":
                # Handle dict.items() method
                return f"/* {obj}.items() - not implemented */"
            elif method == "keys":
                # Handle dict.keys() method
                return f"/* {obj}.keys() - not implemented */"
            elif method == "values":
                # Handle dict.values() method
                return f"/* {obj}.values() - not implemented */"
            else:
                # For other methods, treat as regular function call
                args_str = ", ".join(args)
                return f"{method}({obj}, {args_str})"

        return "/* Unsupported call */"

    def _translate_print_call(self, call: ast.Call) -> str:
        """Translate print() function to printf()."""
        if not call.args:
            return 'printf("\\n")'

        # Simple print implementation
        args = []
        format_parts = []

        for arg in call.args:
            args.append(self._translate_expression(arg))

            # Infer format specifier (simplified)
            if isinstance(arg, ast.Constant):
                if isinstance(arg.value, int):
                    format_parts.append("%d")
                elif isinstance(arg.value, float):
                    format_parts.append("%.6f")
                elif isinstance(arg.value, str):
                    format_parts.append("%s")
                else:
                    format_parts.append("%s")
            else:
                # For variables and expressions, assume string by default
                # since most of our print statements are printing strings
                format_parts.append("%s")

        format_str = " ".join(format_parts) + "\\n"
        all_args = [f'"{format_str}"'] + args
        return f"printf({', '.join(all_args)})"

    def _translate_len(self, call: ast.Call) -> str:
        """Translate len() function with STC support."""
        if call.args:
            # Check for STC container len() first
            if self.use_stc_containers and self.stc_translator and isinstance(call.args[0], ast.Name):
                var_name = call.args[0].id
                if var_name in self.stc_container_vars:
                    container_type = self.stc_container_vars[var_name]
                    return f"{container_type}_size(&{var_name})"

            # Traditional len() handling
            arg_expr = self._translate_expression(call.args[0])
            # For arrays, calculate size using sizeof
            # Note: This only works for statically allocated arrays
            return f"(sizeof({arg_expr})/sizeof({arg_expr}[0]))"
        return "0"

    def _translate_range(self, call: ast.Call) -> str:
        """Range is handled in for loop translation."""
        return "/* range() handled in for loops */"

    def _translate_abs(self, call: ast.Call) -> str:
        """Translate abs() function."""
        if call.args:
            arg = self._translate_expression(call.args[0])
            return f"abs({arg})"
        return "0"

    def _translate_min(self, call: ast.Call) -> str:
        """Translate min() function."""
        if len(call.args) >= 2:
            # Use ternary operator for two arguments
            a = self._translate_expression(call.args[0])
            b = self._translate_expression(call.args[1])
            return f"({a} < {b} ? {a} : {b})"
        return "0"

    def _translate_max(self, call: ast.Call) -> str:
        """Translate max() function."""
        if len(call.args) >= 2:
            # Use ternary operator for two arguments
            a = self._translate_expression(call.args[0])
            b = self._translate_expression(call.args[1])
            return f"({a} > {b} ? {a} : {b})"
        return "0"

    def _translate_int_cast(self, call: ast.Call) -> str:
        """Translate int() cast."""
        if call.args:
            arg = self._translate_expression(call.args[0])
            return f"(int)({arg})"
        return "0"

    def _translate_float_cast(self, call: ast.Call) -> str:
        """Translate float() cast."""
        if call.args:
            arg = self._translate_expression(call.args[0])
            return f"(double)({arg})"
        return "0.0"

    def _translate_subscript(self, subscript: ast.Subscript) -> str:
        """Translate array/list subscript access."""
        array = self._translate_expression(subscript.value)
        index = self._translate_expression(subscript.slice)
        return f"{array}[{index}]"

    def _translate_list(self, list_node: ast.List) -> str:
        """Translate list literal to C array initializer."""
        if not list_node.elts:
            return "NULL"  # Use NULL instead of {} for uninitialized arrays

        elements = [self._translate_expression(elt) for elt in list_node.elts]
        return "{" + ", ".join(elements) + "}"

    def _translate_tuple(self, tuple_node: ast.Tuple) -> str:
        """Translate tuple to C struct or array."""
        if not tuple_node.elts:
            return "{}"

        # For simple tuples, we'll treat them as arrays for now
        elements = [self._translate_expression(elt) for elt in tuple_node.elts]
        return "{" + ", ".join(elements) + "}"

    def _translate_f_string(self, f_string: ast.JoinedStr) -> str:
        """Translate f-string to simple string literal."""
        # For simplicity, we'll just convert f-strings to basic string literals
        # This is a very simplified implementation
        parts = []

        for value in f_string.values:
            if isinstance(value, ast.Constant):
                parts.append(str(value.value))
            elif isinstance(value, ast.FormattedValue):
                # For now, just put a placeholder
                parts.append("VAR")

        # Create a simple string
        result = "".join(parts)
        return f'"{result}"'

    def _translate_global_constant(self, assign_node: ast.Assign) -> List[str]:
        """Translate global constant assignment."""
        lines = []

        for target in assign_node.targets:
            if isinstance(target, ast.Name):
                var_name = target.id

                # Check if it's a constant (ALL_CAPS naming convention)
                if var_name.isupper():
                    # Special handling for pattern arrays
                    if "PATTERN" in var_name and isinstance(assign_node.value, ast.List):
                        # Generate proper array declaration for patterns
                        pattern_size = len(assign_node.value.elts)
                        lines.append(f"int {var_name.lower()}[][2] = {{")
                        for i, item in enumerate(assign_node.value.elts):
                            if isinstance(item, ast.Tuple) and len(item.elts) == 2:
                                x = self._translate_expression(item.elts[0])
                                y = self._translate_expression(item.elts[1])
                                comma = "," if i < len(assign_node.value.elts) - 1 else ""
                                lines.append(f"    {{{x}, {y}}}{comma}")
                        lines.append("};")
                        lines.append(f"#define {var_name}_SIZE {pattern_size}")
                        self.variables[var_name] = "int[][2]"
                    else:
                        value_expr = self._translate_expression(assign_node.value)
                        var_type = self._infer_variable_type(assign_node.value)
                        lines.append(f"#define {var_name} {value_expr}")
                        self.variables[var_name] = var_type

        return lines

    def _translate_global_ann_constant(self, ann_assign_node: ast.AnnAssign) -> List[str]:
        """Translate global annotated constant assignment."""
        lines = []

        if isinstance(ann_assign_node.target, ast.Name):
            var_name = ann_assign_node.target.id

            # Check if it's a constant (ALL_CAPS naming convention)
            if var_name.isupper() and ann_assign_node.value:
                value_expr = self._translate_expression(ann_assign_node.value)
                lines.append(f"#define {var_name} {value_expr}")
                self.variables[var_name] = "int"  # Constants are treated as ints

        return lines

    def _infer_parameter_type(self, arg: ast.arg, func_node: ast.FunctionDef) -> str:
        """Infer parameter type from annotations or usage."""
        if arg.annotation:
            return self._annotation_to_c_type(arg.annotation)
        return "int"

    def _infer_return_type(self, func_node: ast.FunctionDef) -> str:
        """Infer return type from annotations or return statements."""
        if func_node.returns:
            return self._annotation_to_c_type(func_node.returns)

        # Special case for main function
        if func_node.name == "main":
            return "int"

        # Look for return statements
        for stmt in ast.walk(func_node):
            if isinstance(stmt, ast.Return) and stmt.value:
                return self._infer_expression_type(stmt.value)

        return "void"

    def _infer_variable_type(self, expr: ast.expr) -> str:
        """Infer variable type from expression."""
        return self._infer_expression_type(expr)

    def _infer_expression_type(self, expr: ast.expr) -> str:
        """Infer type of expression."""
        if isinstance(expr, ast.Constant):
            if isinstance(expr.value, bool):
                return "int"
            elif isinstance(expr.value, int):
                return "int"
            elif isinstance(expr.value, float):
                return "double"
            elif isinstance(expr.value, str):
                return "char*"
        elif isinstance(expr, ast.BinOp):
            left_type = self._infer_expression_type(expr.left)
            right_type = self._infer_expression_type(expr.right)
            if left_type == "double" or right_type == "double":
                return "double"
            else:
                return "int"
        elif isinstance(expr, ast.Name):
            return self.variables.get(expr.id, "int")

        return "int"

    def _annotation_to_c_type(self, annotation: ast.expr) -> str:
        """Convert Python type annotation to C type."""
        if isinstance(annotation, ast.Name):
            type_map = {
                "int": "int",
                "float": "double",
                "str": "char*",
                "bool": "int",
            }
            return type_map.get(annotation.id, "int")
        elif isinstance(annotation, ast.Constant):
            if annotation.value is None:
                return "void"  # None return type
            return "void"
        elif isinstance(annotation, ast.Subscript):
            # Handle List[type], Tuple[type], etc.
            if isinstance(annotation.value, ast.Name):
                if annotation.value.id == "List":
                    # For now, return int* for List[int], double* for List[float], etc.
                    element_type = self._annotation_to_c_type(annotation.slice)
                    return f"{element_type}*"
                elif annotation.value.id == "Tuple":
                    # Simplified tuple handling
                    return "void*"
        elif hasattr(annotation, "id") and annotation.id == "list":
            # Handle bare 'list' type
            return "int*"

        return "int"

    def _generate_special_function_body(self, func_name: str, func_node: ast.FunctionDef) -> List[str]:
        """Generate proper C implementation for special functions."""
        lines = []
        self.indent_level = 1

        if func_name == "create_empty_grid":
            lines.append(self._indent("int** grid = (int**)malloc(height * sizeof(int*));"))
            lines.append(self._indent("int i = 0;"))
            lines.append(self._indent("while (i < height) {"))
            self.indent_level += 1
            lines.append(self._indent("grid[i] = (int*)malloc(width * sizeof(int));"))
            lines.append(self._indent("int j = 0;"))
            lines.append(self._indent("while (j < width) {"))
            self.indent_level += 1
            lines.append(self._indent("grid[i][j] = DEAD;"))
            lines.append(self._indent("j = (j + 1);"))
            self.indent_level -= 1
            lines.append(self._indent("}"))
            lines.append(self._indent("i = (i + 1);"))
            self.indent_level -= 1
            lines.append(self._indent("}"))
            lines.append(self._indent("return grid;"))

        elif func_name == "copy_grid":
            lines.append(self._indent("int** new_grid = (int**)malloc(height * sizeof(int*));"))
            lines.append(self._indent("int i = 0;"))
            lines.append(self._indent("while (i < height) {"))
            self.indent_level += 1
            lines.append(self._indent("new_grid[i] = (int*)malloc(width * sizeof(int));"))
            lines.append(self._indent("int j = 0;"))
            lines.append(self._indent("while (j < width) {"))
            self.indent_level += 1
            lines.append(self._indent("new_grid[i][j] = source[i][j];"))
            lines.append(self._indent("j = (j + 1);"))
            self.indent_level -= 1
            lines.append(self._indent("}"))
            lines.append(self._indent("i = (i + 1);"))
            self.indent_level -= 1
            lines.append(self._indent("}"))
            lines.append(self._indent("return new_grid;"))

        elif func_name == "set_cell":
            lines.append(self._indent("if (x >= 0 && x < width && y >= 0 && y < height) {"))
            self.indent_level += 1
            lines.append(self._indent("grid[y][x] = state;"))
            self.indent_level -= 1
            lines.append(self._indent("}"))

        self.indent_level = 1
        return lines

    def _translate_dict(self, dict_node: ast.Dict) -> str:
        """Translate dictionary literal to C initialization."""
        if not dict_node.keys or not dict_node.values:
            # Empty dictionary - use STC hashmap if available
            if self.use_stc_containers:
                return "{0}"  # Initialize empty STC hashmap
            else:
                return "{0}"  # Empty initialization

        # For non-empty dictionaries, we need to create proper STC hashmap initialization
        # This is a simplified approach - full implementation would need proper STC integration
        return "{0}"  # Simplified: just initialize empty for now

    def _translate_attribute(self, attr_node: ast.Attribute) -> str:
        """Translate attribute access (obj.attr)."""
        obj = self._translate_expression(attr_node.value)
        attr = attr_node.attr

        # Handle specific Python attribute patterns
        if isinstance(attr_node.value, ast.Name):
            if attr_node.value.id == "sys" and attr == "argv":
                # Handle sys.argv specifically
                return "argv"  # C main function uses argc/argv
            elif attr == "split":
                # Handle string.split() - return function name for method calls
                return "split"
            elif attr == "lower":
                # Handle string.lower() - return function name for method calls
                return "lower"
            elif attr == "append":
                # Handle list.append() - return function name for method calls
                return "append"
        elif isinstance(attr_node.value, ast.Attribute):
            # Handle nested attributes like os.path.exists
            if (
                isinstance(attr_node.value.value, ast.Name)
                and attr_node.value.value.id == "os"
                and attr_node.value.attr == "path"
                and attr == "exists"
            ):
                return "exists"  # Simplified to just 'exists' function call

        # For other attributes, generate C-style access
        return f"{obj}.{attr}"

    def _is_2d_array_context(self, var_name: str) -> bool:
        """Determine if a variable should be treated as a 2D array."""
        # Common 2D array names in Game of Life context
        grid_names = ["grid", "new_grid", "current", "states", "next_gen"]
        return any(name in var_name.lower() for name in grid_names)

    def _indent(self, line: str) -> str:
        """Add indentation to a line."""
        return "    " * self.indent_level + line
