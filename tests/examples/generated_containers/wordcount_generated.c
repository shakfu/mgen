// ========================================
// Word Count - Generated with Inline Containers
// ========================================
// This is a complete, self-contained C program.
// No external dependencies beyond standard library.
//
// Generated by: MGen Container Code Generator (Prototype)
// Philosophy: Self-contained code generation (like C++ templates)

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

// ========== Generated Container: str_int_map ==========
// String â†’ int hash table implementation
// Generated inline for this program (no external dependencies)

// Type definitions and API
/**
 * Simple hash table for string -> int mappings
 * Owns string keys (uses strdup/free)
 * Clean, understandable implementation without macro magic
 */




// Hash table entry
typedef struct mgen_str_int_entry {
    char* key;                          // Owned string (strdup'd)
    int value;
    struct mgen_str_int_entry* next;    // For collision chaining
} mgen_str_int_entry_t;

// Hash table structure
typedef struct {
    mgen_str_int_entry_t** buckets;
    size_t bucket_count;
    size_t size;                        // Number of entries
} mgen_str_int_map_t;

/**
 * Create a new string-to-int map
 * Initial capacity defaults to 16 buckets
 */
mgen_str_int_map_t* mgen_str_int_map_new(void);

/**
 * Create a map with specific initial capacity
 */
mgen_str_int_map_t* mgen_str_int_map_new_with_capacity(size_t capacity);

/**
 * Insert or update a key-value pair
 * Key is copied (strdup), so caller retains ownership of input string
 * Returns true if inserted, false if updated existing key
 */
bool mgen_str_int_map_insert(mgen_str_int_map_t* map, const char* key, int value);

/**
 * Get value for a key
 * Returns pointer to value if found, NULL if not found
 */
int* mgen_str_int_map_get(mgen_str_int_map_t* map, const char* key);

/**
 * Check if key exists in map
 */
bool mgen_str_int_map_contains(mgen_str_int_map_t* map, const char* key);

/**
 * Remove a key-value pair
 * Returns true if removed, false if key didn't exist
 */
bool mgen_str_int_map_remove(mgen_str_int_map_t* map, const char* key);

/**
 * Get number of entries in map
 */
size_t mgen_str_int_map_size(const mgen_str_int_map_t* map);

/**
 * Free all memory associated with map
 * Frees all keys and the map structure itself
 */
void mgen_str_int_map_free(mgen_str_int_map_t* map);

/**
 * Clear all entries but keep the map structure
 */
void mgen_str_int_map_clear(mgen_str_int_map_t* map);

// Implementation
/**
 * Simple hash table for string -> int mappings
 * Implementation using separate chaining for collision resolution
 */


#define DEFAULT_BUCKET_COUNT 16
#define LOAD_FACTOR_THRESHOLD 0.75

/**
 * djb2 hash function - simple and effective for strings
 */
static unsigned long hash_string(const char* str) {
    unsigned long hash = 5381;
    int c;
    while ((c = *str++)) {
        hash = ((hash << 5) + hash) + c; // hash * 33 + c
    }
    return hash;
}

/**
 * Create a new entry
 */
static mgen_str_int_entry_t* entry_new(const char* key, int value) {
    mgen_str_int_entry_t* entry = malloc(sizeof(mgen_str_int_entry_t));
    if (!entry) {
        return NULL;
    }

    entry->key = strdup(key);
    if (!entry->key) {
        free(entry);
        return NULL;
    }

    entry->value = value;
    entry->next = NULL;
    return entry;
}

/**
 * Free an entry and its chain
 */
static void entry_free(mgen_str_int_entry_t* entry) {
    while (entry) {
        mgen_str_int_entry_t* next = entry->next;
        free(entry->key);
        free(entry);
        entry = next;
    }
}

mgen_str_int_map_t* mgen_str_int_map_new(void) {
    return mgen_str_int_map_new_with_capacity(DEFAULT_BUCKET_COUNT);
}

mgen_str_int_map_t* mgen_str_int_map_new_with_capacity(size_t capacity) {
    mgen_str_int_map_t* map = malloc(sizeof(mgen_str_int_map_t));
    if (!map) {
        return NULL;
    }

    map->buckets = calloc(capacity, sizeof(mgen_str_int_entry_t*));
    if (!map->buckets) {
        free(map);
        return NULL;
    }

    map->bucket_count = capacity;
    map->size = 0;
    return map;
}

bool mgen_str_int_map_insert(mgen_str_int_map_t* map, const char* key, int value) {
    if (!map || !key) {
        return false;
    }

    unsigned long hash = hash_string(key);
    size_t index = hash % map->bucket_count;

    // Check if key already exists
    mgen_str_int_entry_t* entry = map->buckets[index];
    while (entry) {
        if (strcmp(entry->key, key) == 0) {
            // Update existing value
            entry->value = value;
            return false; // Updated, not inserted
        }
        entry = entry->next;
    }

    // Insert new entry at head of chain
    mgen_str_int_entry_t* new_entry = entry_new(key, value);
    if (!new_entry) {
        return false;
    }

    new_entry->next = map->buckets[index];
    map->buckets[index] = new_entry;
    map->size++;

    return true; // Inserted
}

int* mgen_str_int_map_get(mgen_str_int_map_t* map, const char* key) {
    if (!map || !key) {
        return NULL;
    }

    unsigned long hash = hash_string(key);
    size_t index = hash % map->bucket_count;

    mgen_str_int_entry_t* entry = map->buckets[index];
    while (entry) {
        if (strcmp(entry->key, key) == 0) {
            return &entry->value;
        }
        entry = entry->next;
    }

    return NULL;
}

bool mgen_str_int_map_contains(mgen_str_int_map_t* map, const char* key) {
    return mgen_str_int_map_get(map, key) != NULL;
}

bool mgen_str_int_map_remove(mgen_str_int_map_t* map, const char* key) {
    if (!map || !key) {
        return false;
    }

    unsigned long hash = hash_string(key);
    size_t index = hash % map->bucket_count;

    mgen_str_int_entry_t** entry_ptr = &map->buckets[index];
    while (*entry_ptr) {
        mgen_str_int_entry_t* entry = *entry_ptr;
        if (strcmp(entry->key, key) == 0) {
            *entry_ptr = entry->next;
            free(entry->key);
            free(entry);
            map->size--;
            return true;
        }
        entry_ptr = &entry->next;
    }

    return false;
}

size_t mgen_str_int_map_size(const mgen_str_int_map_t* map) {
    return map ? map->size : 0;
}

void mgen_str_int_map_clear(mgen_str_int_map_t* map) {
    if (!map) {
        return;
    }

    for (size_t i = 0; i < map->bucket_count; i++) {
        if (map->buckets[i]) {
            entry_free(map->buckets[i]);
            map->buckets[i] = NULL;
        }
    }

    map->size = 0;
}

void mgen_str_int_map_free(mgen_str_int_map_t* map) {
    if (!map) {
        return;
    }

    mgen_str_int_map_clear(map);
    free(map->buckets);
    free(map);
}

// ========== End of Generated Container ==========


// ========== User Code ==========

int main(void) {
    // Create word frequency map
    mgen_str_int_map_t* word_counts = mgen_str_int_map_new();
    if (!word_counts) {
        fprintf(stderr, "Failed to create map\n");
        return 1;
    }

    // Count word frequencies
    const char* words[] = {
        "the", "quick", "brown", "fox",
        "jumps", "over", "the", "lazy",
        "dog", "the", "fox", "is", "quick"
    };
    size_t num_words = sizeof(words) / sizeof(words[0]);

    for (size_t i = 0; i < num_words; i++) {
        const char* word = words[i];
        int* current_count = mgen_str_int_map_get(word_counts, word);

        if (current_count) {
            // Word exists, increment count
            mgen_str_int_map_insert(word_counts, word, *current_count + 1);
        } else {
            // New word, insert with count 1
            mgen_str_int_map_insert(word_counts, word, 1);
        }
    }

    // Print results
    printf("Word frequencies:\n");
    const char* test_words[] = {"the", "quick", "fox", "dog", "lazy"};
    for (size_t i = 0; i < 5; i++) {
        const char* word = test_words[i];
        int* count = mgen_str_int_map_get(word_counts, word);
        if (count) {
            printf("  %s: %d\n", word, *count);
        }
    }

    // Verify 'the' appears 3 times
    int* the_count = mgen_str_int_map_get(word_counts, "the");
    int result = (the_count && *the_count == 3) ? 0 : 1;

    // Cleanup
    mgen_str_int_map_free(word_counts);

    return result;
}